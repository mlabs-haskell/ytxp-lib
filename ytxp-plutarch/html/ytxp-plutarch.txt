-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Control scripts, types, and utilities for the YTxP architecture
--   
--   Control scripts, types, and utilities for the YTxP architecture
@package ytxp-plutarch
@version 0.1.0

module Cardano.YTxP
data YTxPParams
linker :: Linker YTxPParams (ScriptExport YTxPParams)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.YTxP.YTxPParams
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.YTxP.YTxPParams
instance GHC.Generics.Generic Cardano.YTxP.YTxPParams
instance GHC.Show.Show Cardano.YTxP.YTxPParams


-- | have some scripts fully implemented yet.
module Cardano.YTxP.Control.Stubs

-- | A validator that will never fail
alwaysSucceedsValidator :: forall (s :: S). Term s (PData :--> (PData :--> (PScriptContext :--> POpaque)))

-- | A two argument script (minting policy or staking validator) that will
--   never fail
alwaysSucceedsTwoArgumentScript :: forall (s :: S). Term s (PData :--> (PScriptContext :--> POpaque))

-- | Compile a nonce into the script, changing the script hash. This can be
--   useful if you need many stubbed validators with different addresses.
noncedValidatorWrapper :: forall (nonceType :: S -> Type) (s :: S). Term s nonceType -> Term s (PData :--> (PData :--> (PScriptContext :--> POpaque))) -> Term s (PData :--> (PData :--> (PScriptContext :--> POpaque)))

-- | Compiles a nonce into the script, changing the script hashes. This is
--   useful if you need many stubbed validators with different addresses
noncedTwoArgumentScriptWrapper :: forall (nonceType :: S -> Type) (s :: S). Term s nonceType -> Term s (PData :--> (PScriptContext :--> POpaque)) -> Term s (PData :--> (PScriptContext :--> POpaque))


-- | Vendored utilities from open source libraries. See the appropriate
--   License for details on usage.
module Cardano.YTxP.Control.Vendored

-- | Wrapper for deriving <a>PConstantDecl</a> using an Integer
--   representation via <a>Enum</a>.
--   
--   Vendored from LPE TODO: Licensing info
newtype DerivePConstantViaEnum (h :: Type) (p :: S -> Type)
DerivePConstantEnum :: h -> DerivePConstantViaEnum (h :: Type) (p :: S -> Type)

-- | Wrapper for deriving <a>ToData</a>, <a>FromData</a> using an Integer
--   representation via <a>Enum</a>.
--   
--   Vendored from LPE TODO: Licensing info
newtype EnumIsData (a :: Type)
EnumIsData :: a -> EnumIsData (a :: Type)

-- | Wrapper for deriving <a>ToData</a>, <a>FromData</a> using the List
--   constructor of Data to represent a Product type.
--   
--   It is recommended to use <a>PlutusTypeDataList</a> when deriving
--   <a>PlutusType</a> as it provides some basic safety by ensuring
--   Plutarch types have an Inner type of <a>PDataRecord</a>.
--   
--   Uses <a>gProductToBuiltinData</a>, <tt>gproductFromBuiltinData</tt>.
--   
--   <h1>Example</h1>
--   
--   <pre>
--   import qualified Generics.SOP as SOP
--   
--   data Foo =
--     Foo Integer [Integer]
--     deriving stock (Generic)
--     deriving anyclass (SOP.Generic)
--     deriving (FromData, ToData) via (ProductIsData Foo)
--     deriving (PConstantDecl) via (DerivePConstantViaDataList Foo PFoo)
--   
--   instance PUnsafeLiftDecl PFoo where type PLifted PFoo = Foo
--   
--   newtype PFoo s
--       = PFoo
--         ( Term s
--             ( PDataRecord
--                 '[ "abc" ':= PInteger
--                  , "def" ':= PBuiltinList (PAsData PInteger)
--                  ]
--             )
--         )
--     deriving stock (Generic)
--     deriving anyclass (SOP.Generic)
--     deriving anyclass (PlutusType, PIsData)
--   
--   instance DerivePlutusType PFoo where
--      type DPTStrat _ = PlutusTypeDataList
--   </pre>
newtype ProductIsData (a :: Type)
ProductIsData :: a -> ProductIsData (a :: Type)

-- | Vendored from LPE @since 3.8.0
unProductIsData :: forall (a :: Type). ProductIsData a -> a

-- | Variant of <tt>PConstantViaData</tt> using the List repr from
--   <a>ProductIsData</a>
newtype DerivePConstantViaDataList (h :: Type) (p :: S -> Type)
DerivePConstantViaDataList :: h -> DerivePConstantViaDataList (h :: Type) (p :: S -> Type)

-- | PlutusTypeEnumData
--   
--   Vendored from LPE TODO: Licensing info
data PlutusTypeEnumData

-- | Vendored from LPE @since 3.5.0
data PlutusTypeDataList

-- | Apply a function to an argument on the compiled <a>Script</a> level.
--   
--   Vendored from LPE TODO: Licensing info
applyScript :: Script -> Script -> Script
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Cardano.YTxP.Control.Vendored.PlutusTypeDataList
instance forall (p :: Plutarch.Internal.S -> GHC.Types.Type). (Plutarch.Internal.Generic.PGeneric p, (Plutarch.Internal.Generic.PCode p :: [[Plutarch.Internal.PType]]) GHC.Types.~ ((':) @[Plutarch.Internal.S -> GHC.Types.Type] ((':) @(Plutarch.Internal.S -> GHC.Types.Type) (Cardano.YTxP.Control.Vendored.GetPRecord p) ('[] @(Plutarch.Internal.S -> GHC.Types.Type))) ('[] @[Plutarch.Internal.S -> GHC.Types.Type]) :: [[Plutarch.Internal.PType]]), Cardano.YTxP.Control.Vendored.MatchTypes (Cardano.YTxP.Control.Vendored.UD (Cardano.YTxP.Control.Vendored.GetRecordTypes (Generics.SOP.Universe.Code (Plutarch.Lift.PLifted p)))) (Cardano.YTxP.Control.Vendored.PUnlabel (Cardano.YTxP.Control.Vendored.GetPRecord' (Plutarch.Internal.Generic.PCode p)))) => Cardano.YTxP.Control.Vendored.IsPlutusTypeDataList p
instance forall h (p :: Plutarch.Internal.S -> GHC.Types.Type). (PlutusTx.IsData.Class.FromData h, PlutusTx.IsData.Class.ToData h, Plutarch.Lift.PLift p) => Plutarch.Lift.PConstantDecl (Cardano.YTxP.Control.Vendored.DerivePConstantViaDataList h p)
instance forall a (repr :: [GHC.Types.Type]). (Generics.SOP.Universe.IsProductType a repr, Data.SOP.Constraint.All @GHC.Types.Type PlutusTx.IsData.Class.ToData repr) => PlutusTx.IsData.Class.ToData (Cardano.YTxP.Control.Vendored.ProductIsData a)
instance forall a (repr :: [GHC.Types.Type]). (Generics.SOP.Universe.IsProductType a repr, Data.SOP.Constraint.All @GHC.Types.Type PlutusTx.IsData.Class.UnsafeFromData repr) => PlutusTx.IsData.Class.UnsafeFromData (Cardano.YTxP.Control.Vendored.ProductIsData a)
instance forall a (repr :: [GHC.Types.Type]). (Generics.SOP.Universe.IsProductType a repr, Data.SOP.Constraint.All @GHC.Types.Type PlutusTx.IsData.Class.FromData repr) => PlutusTx.IsData.Class.FromData (Cardano.YTxP.Control.Vendored.ProductIsData a)
instance forall (p :: Plutarch.Internal.S -> GHC.Types.Type) h. (Plutarch.Lift.PLift p, GHC.Enum.Enum h, Plutarch.Internal.PlutusType.DerivePlutusType p, (Plutarch.Internal.PlutusType.DPTStrat p :: GHC.Types.Type) GHC.Types.~ (Cardano.YTxP.Control.Vendored.PlutusTypeEnumData :: GHC.Types.Type)) => Plutarch.Lift.PConstantDecl (Cardano.YTxP.Control.Vendored.DerivePConstantViaEnum h p)
instance forall (p :: Plutarch.Internal.PType). (Plutarch.Internal.Generic.PGeneric p, forall (s :: Plutarch.Internal.S). GHC.Enum.Enum (p s), forall (s :: Plutarch.Internal.S). GHC.Enum.Bounded (p s)) => Cardano.YTxP.Control.Vendored.IsPlutusTypeEnumData p
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Cardano.YTxP.Control.Vendored.PlutusTypeEnumData
instance forall a. GHC.Enum.Enum a => PlutusTx.IsData.Class.ToData (Cardano.YTxP.Control.Vendored.EnumIsData a)
instance forall a. GHC.Enum.Enum a => PlutusTx.IsData.Class.FromData (Cardano.YTxP.Control.Vendored.EnumIsData a)
instance forall a. GHC.Enum.Enum a => PlutusTx.IsData.Class.UnsafeFromData (Cardano.YTxP.Control.Vendored.EnumIsData a)

module Utils

-- | Convert a <tt>ScriptHash</tt> to a <tt>CurrencySymbol</tt>, which has
--   the same representation
pscriptHashToCurrencySymbol :: Term s PScriptHash -> Term s PCurrencySymbol
pmember :: PIsData k => Term s (k :--> (PMap any k v :--> PBool))
pcheck :: forall (s :: S). Term s PBool -> Term s POpaque


-- | Add note on orphan instances. We want to have the haskell types come
--   from the shared SDK so that other onchain implementations can reuse
--   those same types. This however, forces us to declare orphan instances
--   for haskell -&gt; plutarch conversion
module Cardano.YTxP.Control.Yielding

-- | Given a list of reference inputs and a Yielding Redeemer, dig out the
--   authorised script hash by:
--   
--   <ul>
--   <li>Indexing the reference inputs according to the redeemer</li>
--   <li>Checking the fetched reference input for the correct
--   AuthorisedScriptsSTCS</li>
--   <li>Returning the AuthorisedScriptHash</li>
--   </ul>
getAuthorisedScriptHash :: forall (s :: S). Term s (PCurrencySymbol :--> (PBuiltinList PTxInInfo :--> (PYieldingRedeemer :--> PScriptHash)))
data PAuthorisedScriptPurpose (s :: S)
PMinting :: PAuthorisedScriptPurpose (s :: S)
PSpending :: PAuthorisedScriptPurpose (s :: S)
PRewarding :: PAuthorisedScriptPurpose (s :: S)
data PYieldingRedeemer (s :: S)
instance Plutarch.Builtin.PIsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex
instance Plutarch.Internal.PlutusType.PlutusType Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex s)
instance Plutarch.Bool.PEq Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose
instance Plutarch.Builtin.PIsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose
instance Plutarch.Internal.PlutusType.PlutusType Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose
instance forall (s :: Plutarch.Internal.S). GHC.Enum.Bounded (Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose s)
instance forall (s :: Plutarch.Internal.S). GHC.Enum.Enum (Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose s)
instance Plutarch.Builtin.PIsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex
instance Plutarch.Internal.PlutusType.PlutusType Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex s)
instance Plutarch.DataRepr.Internal.Field.PDataFields Cardano.YTxP.Control.Yielding.PYieldingRedeemer
instance Plutarch.Builtin.PIsData Cardano.YTxP.Control.Yielding.PYieldingRedeemer
instance Plutarch.Internal.PlutusType.PlutusType Cardano.YTxP.Control.Yielding.PYieldingRedeemer
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Cardano.YTxP.Control.Yielding.PYieldingRedeemer s)
instance Plutarch.Lift.PConstantDecl Cardano.YTxP.SDK.Redeemers.AuthorisedScriptIndex
instance Plutarch.Lift.PConstantDecl Cardano.YTxP.SDK.Redeemers.AuthorisedScriptPurpose
instance Plutarch.Lift.PConstantDecl Cardano.YTxP.SDK.Redeemers.AuthorisedScriptProofIndex
instance Plutarch.Lift.PConstantDecl Cardano.YTxP.SDK.Redeemers.YieldingRedeemer
instance Plutarch.Internal.PlutusType.DerivePlutusType Cardano.YTxP.Control.Yielding.PYieldingRedeemer
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Cardano.YTxP.Control.Yielding.PYieldingRedeemer)
instance Plutarch.Lift.PUnsafeLiftDecl Cardano.YTxP.Control.Yielding.PYieldingRedeemer
instance Plutarch.Internal.PlutusType.DerivePlutusType Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex)
instance Plutarch.Lift.PUnsafeLiftDecl Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex
instance Plutarch.Internal.PlutusType.DerivePlutusType Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose)
instance Plutarch.Lift.PUnsafeLiftDecl Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose
instance Plutarch.Internal.PlutusType.DerivePlutusType Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex)
instance Plutarch.Lift.PUnsafeLiftDecl Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex


-- | This module export a helper function that produces a two argument
--   yielding script that we use to implement the logic for yielding
--   validator, minting policy and staking validator
module Cardano.YTxP.Control.Yielding.Helper
yieldingHelper :: forall (s :: S). Term s (PCurrencySymbol :--> (PData :--> (PScriptContext :--> POpaque)))

module Cardano.YTxP.Control.Yielding.Scripts
scripts :: Config -> RawScriptExport
