-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Control scripts, types, and utilities for the YTxP architecture
--   
--   Control scripts, types, and utilities for the YTxP architecture
@package ytxp-plutarch
@version 0.1.0


-- | This module exposes a flexible way to generate test cases that go
--   through a pre-processing -&gt; pre-condition -&gt; execution -&gt;
--   post-condition pipeline.
--   
--   The intention is to provide an easier interface to re-using predicates
--   and pre-processors between many tests and between different _kinds_ of
--   tests, including nominal and attack cases, as well as unit and
--   property testing.
--   
--   This module is currently targeted primarily at tests run on the CEK
--   machine. In the future, it may be expanded to be polymorphic in terms
--   of arbitrary "computation". The current computation type is
--   essentially hard-coded to
--   
--   (Maybe Datum, Redeemer, ScriptContext, Script) -&gt; (Either EvalError
--   Script, ExBudget, Logs)
--   
--   but this could be expanded so that other types of tests (emulator,
--   integration, serialization, golden) could be run as well.
module Cardano.TestUtils

-- | PreProcessing -- could be used for normalization or attacks
data PreProcessor err input
mkPreProcessor :: (input -> Either err input) -> PreProcessor err input

-- | Given a list of preprocessors, apply them in order from left to right.
--   Returns the first error encountered, if any.
preProcess :: [PreProcessor err input] -> input -> Either err input

-- | Checks for after the preprocessing is run. Could be used to check for
--   balancing, etc
--   
--   TODO: rewrite as Kleisli?
data PreCondition err input
mkPreCondition :: (input -> Maybe err) -> PreCondition err input

-- | Check a list of pre-conditions, returning the first error encountered
checkPreConditions :: [PreCondition err input] -> input -> Maybe err

-- | Represents a partial post-condition predicate on the result of a call
--   to `evalScript :: Script -&gt; (Either EvalError Script, ExBudget,
--   [Text]) ` TODO: Rewrite as Kleisli?
--   
--   TODO: If its possible to turn budgeting off, we should. These scripts
--   will be run with some logging output, and they wouldn't in production;
--   thus costing is not actually representative of anything useful.
data PostCondition err output
mkPostCondition :: (output -> Maybe err) -> PostCondition err output

-- | Check a list of post-conditions from left to right, returning the
--   first error encountered
checkPostConditions :: [PostCondition err output] -> output -> Maybe err

-- | A type representing a named test case for a transaction family. NOTE:
--   if the `sc-tools` work ends up panning out, the <tt>args</tt> and
--   <tt>script</tt> arguments might get combined to a (Maybe Datum,
--   Redeemer, ScriptContext, Script)
data PipelinedTestCase errPP errPreC errPostC input output
PipelinedTestCase :: String -> [PreProcessor errPP input] -> [PreCondition errPreC input] -> input -> (input -> output) -> [PostCondition errPostC output] -> PipelinedTestCase errPP errPreC errPostC input output

-- | Name of the test case
[$sel:name:PipelinedTestCase] :: PipelinedTestCase errPP errPreC errPostC input output -> String

-- | Pre-processors (normalizers or attacks); applied in order from left to
--   right
[$sel:preProcessors:PipelinedTestCase] :: PipelinedTestCase errPP errPreC errPostC input output -> [PreProcessor errPP input]

-- | Pre-condition Checking. Run after pre-processing
[$sel:preConditions:PipelinedTestCase] :: PipelinedTestCase errPP errPreC errPostC input output -> [PreCondition errPreC input]

-- | the input to the computation
[$sel:input:PipelinedTestCase] :: PipelinedTestCase errPP errPreC errPostC input output -> input

-- | the computation to run
[$sel:computation:PipelinedTestCase] :: PipelinedTestCase errPP errPreC errPostC input output -> input -> output

-- | Post conditions are checked after script execution
[$sel:postConditions:PipelinedTestCase] :: PipelinedTestCase errPP errPreC errPostC input output -> [PostCondition errPostC output]

-- | A sum type to collect the errors of a pipelined test case
data PipelinedTestErrors errPP errPreC errPostC
PipelinedPreProcessorError :: errPP -> PipelinedTestErrors errPP errPreC errPostC
PipelinedPreConditionError :: errPreC -> PipelinedTestErrors errPP errPreC errPostC
PipelinedPostConditionError :: errPostC -> PipelinedTestErrors errPP errPreC errPostC

-- | Behavior of this function:
--   
--   <ul>
--   <li>1.) All pre-processors are run in order from left to right on the
--   arguments. If any pre-processor returns a Left, then the resulting
--   test case fails with the appropriate error message.</li>
--   <li>2.) All pre-condition checks are run on the pre-processed
--   arguments. If any pre-condition checks return Nothing, then the
--   resulting test case fails with the appropriate error meesage.</li>
--   <li>3.) The pre-processed arguments are fed to the script.</li>
--   <li>4.) The results of (3) are checked against each post-condition. If
--   any of the post-condition checks fail, the test case fails with the
--   appropriate error message</li>
--   <li>5.) If none of the above checks cause a failure, the test
--   succeeds.</li>
--   </ul>
pipelinedUnitCase :: (Show errPP, Show errPreC, Show errPostC) => PipelinedTestCase errPP errPreC errPostC input output -> TestTree

-- | A sum type of the errors for a TxFCEKCase
data TxFCEKCase errPP errPreC errPostC

-- | The arguments needed to run a YTxP-style transaction family (single
--   script) on the CEK Machine. Includes a datum (for validators only), a
--   redeemer, script context, and the script itself.
data TxFCEKInput
TxFCEKInput :: Maybe Datum -> Redeemer -> ScriptContext -> Script -> TxFCEKInput
[$sel:cekDatum:TxFCEKInput] :: TxFCEKInput -> Maybe Datum
[$sel:cekRedeemer:TxFCEKInput] :: TxFCEKInput -> Redeemer
[$sel:cekScriptContext:TxFCEKInput] :: TxFCEKInput -> ScriptContext
[$sel:cekScript:TxFCEKInput] :: TxFCEKInput -> Script

-- | The data produced by the CEK machine when run against a TxFCEKInput.
data TxFCEKOutput
TxFCEKOutput :: Either EvalError Script -> ExBudget -> [Text] -> TxFCEKOutput
[$sel:cekResult:TxFCEKOutput] :: TxFCEKOutput -> Either EvalError Script
[$sel:cekExBudget:TxFCEKOutput] :: TxFCEKOutput -> ExBudget
[$sel:cekLogs:TxFCEKOutput] :: TxFCEKOutput -> [Text]

-- | Create a TxFCEKCase by filling in the computation via running the
--   script.
mkTxFCEKCase :: forall (errPP :: Type) (errPreC :: Type) (errPostC :: Type). String -> [PreProcessor errPP TxFCEKInput] -> [PreCondition errPreC TxFCEKInput] -> TxFCEKInput -> [PostCondition errPostC TxFCEKOutput] -> TxFCEKCase errPP errPreC errPostC
txfCEKUnitCase :: forall (errPP :: Type) (errPreC :: Type) (errPostC :: Type). (Show errPP, Show errPreC, Show errPostC) => TxFCEKCase errPP errPreC errPostC -> TestTree

-- | A post condition for checking whether the script execution succeeded
--   or failed You must supply a way to turn a generic evaluation error
--   into your domain-specific error type
nominalPostCondition :: ((EvalError, [Text]) -> err) -> PostCondition err TxFCEKOutput

-- | A basic nominal case unit test. Only checks if the script succeeds;
--   does not do pre-processing, pre-condition checking, or other
--   post-condition checks.
--   
--   Throws a generic <a>String</a> error (not domain-specific)
nominalCaseBasic :: String -> Maybe Datum -> Redeemer -> ScriptContext -> Script -> TxFCEKCase String String String

-- | The attackCaseRegex-style functions will fail with - A (Nothing,
--   [Text]) if the script succeeds. [Text] in the tuple contains the logs.
--   - A (Just Int, [Text]) if the script fails, but the regex does not
--   match exactly once. The int contains the number of matches
attackCaseRegexPostCondition :: ((Maybe Int, [Text]) -> err) -> RE -> PostCondition err TxFCEKOutput

-- | Generate an "attack case" test tree, given a name, an expected failure
--   condition, the arguments to the script, an attack, and the script
--   itself.
--   
--   The expected failure condition is matched as a regex. It must match
--   the logs exactly once.
attackCaseBasicRegex :: String -> RE -> Maybe Datum -> Redeemer -> ScriptContext -> Script -> PreProcessor errPP TxFCEKInput -> TxFCEKCase errPP String String
instance GHC.Show.Show Cardano.TestUtils.TxFCEKInput
instance GHC.Classes.Eq Cardano.TestUtils.TxFCEKInput
instance GHC.Show.Show Cardano.TestUtils.TxFCEKOutput
instance GHC.Classes.Eq Cardano.TestUtils.TxFCEKOutput

module Cardano.YTxP
data YTxPParams
validatorLinker :: Linker YTxPParams (ScriptExport YTxPParams)
stakeValidatorLinker :: Linker YTxPParams (ScriptExport YTxPParams)
mintingPolicyLinker :: Linker YTxPParams (ScriptExport YTxPParams)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.YTxP.YTxPParams
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.YTxP.YTxPParams
instance GHC.Generics.Generic Cardano.YTxP.YTxPParams
instance GHC.Show.Show Cardano.YTxP.YTxPParams


-- | have some scripts fully implemented yet.
module Cardano.YTxP.Control.Stubs

-- | A validator that will never fail
alwaysSucceedsValidator :: forall (s :: S). Term s (PData :--> (PData :--> (PScriptContext :--> POpaque)))

-- | A two argument script (minting policy or staking validator) that will
--   never fail
alwaysSucceedsTwoArgumentScript :: forall (s :: S). Term s (PData :--> (PScriptContext :--> POpaque))

-- | Compile a nonce into the script, changing the script hash. This can be
--   useful if you need many stubbed validators with different addresses.
noncedValidatorWrapper :: forall (nonceType :: S -> Type) (s :: S). Term s nonceType -> Term s (PData :--> (PData :--> (PScriptContext :--> POpaque))) -> Term s (PData :--> (PData :--> (PScriptContext :--> POpaque)))

-- | Compiles a nonce into the script, changing the script hashes. This is
--   useful if you need many stubbed validators with different addresses
noncedTwoArgumentScriptWrapper :: forall (nonceType :: S -> Type) (s :: S). Term s nonceType -> Term s (PData :--> (PScriptContext :--> POpaque)) -> Term s (PData :--> (PScriptContext :--> POpaque))


-- | Vendored utilities from open source libraries. See the appropriate
--   License for details on usage.
module Cardano.YTxP.Control.Vendored

-- | Wrapper for deriving <a>PConstantDecl</a> using an Integer
--   representation via <a>Enum</a>.
--   
--   Vendored from LPE TODO: Licensing info
newtype DerivePConstantViaEnum (h :: Type) (p :: S -> Type)
DerivePConstantEnum :: h -> DerivePConstantViaEnum (h :: Type) (p :: S -> Type)

-- | PlutusTypeEnumData
--   
--   Vendored from LPE TODO: Licensing info
data PlutusTypeEnumData
instance forall (p :: Plutarch.Internal.S -> GHC.Types.Type) h. (Plutarch.Lift.PLift p, GHC.Enum.Enum h, Plutarch.Internal.PlutusType.DerivePlutusType p, (Plutarch.Internal.PlutusType.DPTStrat p :: GHC.Types.Type) GHC.Types.~ (Cardano.YTxP.Control.Vendored.PlutusTypeEnumData :: GHC.Types.Type)) => Plutarch.Lift.PConstantDecl (Cardano.YTxP.Control.Vendored.DerivePConstantViaEnum h p)
instance forall (p :: Plutarch.Internal.PType). (Plutarch.Internal.Generic.PGeneric p, forall (s :: Plutarch.Internal.S). GHC.Enum.Enum (p s), forall (s :: Plutarch.Internal.S). GHC.Enum.Bounded (p s)) => Cardano.YTxP.Control.Vendored.IsPlutusTypeEnumData p
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Cardano.YTxP.Control.Vendored.PlutusTypeEnumData

module Utils

-- | Convert a <tt>ScriptHash</tt> to a <tt>CurrencySymbol</tt>, which has
--   the same representation
pscriptHashToCurrencySymbol :: Term s PScriptHash -> Term s PCurrencySymbol
pmember :: PIsData k => Term s (k :--> (PMap any k v :--> PBool))
pcheck :: forall (s :: S). Term s PBool -> Term s POpaque


-- | Add note on orphan instances. We want to have the haskell types come
--   from the shared SDK so that other onchain implementations can reuse
--   those same types. This however, forces us to declare orphan instances
--   for haskell -&gt; plutarch conversion
module Cardano.YTxP.Control.Yielding

-- | Given a list of reference inputs and a Yielding Redeemer, dig out the
--   authorised script hash by:
--   
--   <ul>
--   <li>Indexing the reference inputs according to the redeemer</li>
--   <li>Checking the fetched reference input for the correct
--   AuthorisedScriptsSTCS</li>
--   <li>Returning the AuthorisedScriptHash</li>
--   </ul>
getAuthorisedScriptHash :: forall (s :: S). Term s (PCurrencySymbol :--> (PBuiltinList (PAsData PTxInInfo) :--> (PYieldingRedeemer :--> PScriptHash)))
data PAuthorisedScriptPurpose (s :: S)
PMinting :: PAuthorisedScriptPurpose (s :: S)
PSpending :: PAuthorisedScriptPurpose (s :: S)
PRewarding :: PAuthorisedScriptPurpose (s :: S)
data PYieldingRedeemer (s :: S)
instance Plutarch.Builtin.PIsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex
instance Plutarch.Internal.PlutusType.PlutusType Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex s)
instance Plutarch.Bool.PEq Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose
instance Plutarch.Builtin.PIsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose
instance Plutarch.Internal.PlutusType.PlutusType Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose
instance forall (s :: Plutarch.Internal.S). GHC.Enum.Bounded (Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose s)
instance forall (s :: Plutarch.Internal.S). GHC.Enum.Enum (Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose s)
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose s)
instance Plutarch.Builtin.PIsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex
instance Plutarch.Internal.PlutusType.PlutusType Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex s)
instance Plutarch.DataRepr.Internal.Field.PDataFields Cardano.YTxP.Control.Yielding.PYieldingRedeemer
instance Plutarch.Builtin.PIsData Cardano.YTxP.Control.Yielding.PYieldingRedeemer
instance Plutarch.Internal.PlutusType.PlutusType Cardano.YTxP.Control.Yielding.PYieldingRedeemer
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Cardano.YTxP.Control.Yielding.PYieldingRedeemer s)
instance Plutarch.Lift.PConstantDecl Cardano.YTxP.SDK.Redeemers.AuthorisedScriptIndex
instance Plutarch.Lift.PConstantDecl Cardano.YTxP.SDK.Redeemers.AuthorisedScriptPurpose
instance Plutarch.Lift.PConstantDecl Cardano.YTxP.SDK.Redeemers.AuthorisedScriptProofIndex
instance Plutarch.Lift.PConstantDecl Cardano.YTxP.SDK.Redeemers.YieldingRedeemer
instance Plutarch.Internal.PlutusType.DerivePlutusType Cardano.YTxP.Control.Yielding.PYieldingRedeemer
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Cardano.YTxP.Control.Yielding.PYieldingRedeemer)
instance Plutarch.Lift.PUnsafeLiftDecl Cardano.YTxP.Control.Yielding.PYieldingRedeemer
instance Plutarch.Internal.PlutusType.DerivePlutusType Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex)
instance Plutarch.Lift.PUnsafeLiftDecl Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex
instance Plutarch.Internal.PlutusType.DerivePlutusType Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose)
instance Plutarch.Lift.PUnsafeLiftDecl Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose
instance Plutarch.Internal.PlutusType.DerivePlutusType Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex)
instance Plutarch.Lift.PUnsafeLiftDecl Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex


-- | This module export a helper function that produces a two argument
--   yielding script that we use to implement the logic for yielding
--   validator, minting policy and staking validator
module Cardano.YTxP.Control.Yielding.Helper
yieldingHelper :: forall (s :: S). Term s (PCurrencySymbol :--> (PData :--> (PScriptContext :--> POpaque)))

module Cardano.YTxP.Control.Yielding.Scripts

-- | Exports the yielding validator, yielding minting policy and yielding
--   staking validator from a given Plutarch <tt>Config</tt>
scripts :: Config -> RawScriptExport

-- | Yielding Validator
yieldingV :: forall (s :: S). Term s (PCurrencySymbol :--> (PData :--> (PData :--> (PScriptContext :--> POpaque))))

-- | Yielding Minting Policy
yieldingMP :: forall (s :: S). Term s (PCurrencySymbol :--> (PInteger :--> (PData :--> (PScriptContext :--> POpaque))))

-- | Yielding Staking Validator
yieldingSV :: forall (s :: S). Term s (PCurrencySymbol :--> (PInteger :--> (PData :--> (PScriptContext :--> POpaque))))
