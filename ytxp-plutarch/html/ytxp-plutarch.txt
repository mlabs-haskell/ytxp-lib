-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Control scripts, types, and utilities for the YTxP architecture
--   
--   Control scripts, types, and utilities for the YTxP architecture
@package ytxp-plutarch
@version 0.2.0


-- | This module exposes a flexible way to generate test cases that go
--   through a pre-processing -&gt; pre-condition -&gt; execution -&gt;
--   post-condition pipeline.
--   
--   The intention is to provide an easier interface to re-using predicates
--   and pre-processors between many tests and between different _kinds_ of
--   tests, including nominal and attack cases, as well as unit and
--   property testing.
--   
--   This module is currently targeted primarily at tests run on the CEK
--   machine. In the future, it may be expanded to be polymorphic in terms
--   of arbitrary "computation". The current computation type is
--   essentially hard-coded to
--   
--   (Maybe Datum, Redeemer, ScriptContext, Script) -&gt; (Either EvalError
--   Script, ExBudget, Logs)
--   
--   but this could be expanded so that other types of tests (emulator,
--   integration, serialization, golden) could be run as well.
module Cardano.TestUtils

-- | PreProcessing -- could be used for normalization or attacks
data PreProcessor err input
mkPreProcessor :: (input -> Either err input) -> PreProcessor err input

-- | Given a list of preprocessors, apply them in order from left to right.
--   Returns the first error encountered, if any.
preProcess :: [PreProcessor err input] -> input -> Either err input

-- | Checks for after the preprocessing is run. Could be used to check for
--   balancing, etc
--   
--   TODO: rewrite as Kleisli?
data PreCondition err input
mkPreCondition :: (input -> Maybe err) -> PreCondition err input

-- | Check a list of pre-conditions, returning the first error encountered
checkPreConditions :: [PreCondition err input] -> input -> Maybe err

-- | Represents a partial post-condition predicate on the result of a call
--   to `evalScript :: Script -&gt; (Either EvalError Script, ExBudget,
--   [Text]) ` TODO: Rewrite as Kleisli?
--   
--   TODO: If its possible to turn budgeting off, we should. These scripts
--   will be run with some logging output, and they wouldn't in production;
--   thus costing is not actually representative of anything useful.
data PostCondition err output
mkPostCondition :: (output -> Maybe err) -> PostCondition err output

-- | Check a list of post-conditions from left to right, returning the
--   first error encountered
checkPostConditions :: [PostCondition err output] -> output -> Maybe err

-- | A type representing a named test case for a transaction family. NOTE:
--   if the `sc-tools` work ends up panning out, the <tt>args</tt> and
--   <tt>script</tt> arguments might get combined to a (Maybe Datum,
--   Redeemer, ScriptContext, Script)
data PipelinedTestCase errPP errPreC errPostC input output
PipelinedTestCase :: String -> [PreProcessor errPP input] -> [PreCondition errPreC input] -> input -> (input -> output) -> [PostCondition errPostC output] -> PipelinedTestCase errPP errPreC errPostC input output

-- | Name of the test case
[$sel:name:PipelinedTestCase] :: PipelinedTestCase errPP errPreC errPostC input output -> String

-- | Pre-processors (normalizers or attacks); applied in order from left to
--   right
[$sel:preProcessors:PipelinedTestCase] :: PipelinedTestCase errPP errPreC errPostC input output -> [PreProcessor errPP input]

-- | Pre-condition Checking. Run after pre-processing
[$sel:preConditions:PipelinedTestCase] :: PipelinedTestCase errPP errPreC errPostC input output -> [PreCondition errPreC input]

-- | the input to the computation
[$sel:input:PipelinedTestCase] :: PipelinedTestCase errPP errPreC errPostC input output -> input

-- | the computation to run
[$sel:computation:PipelinedTestCase] :: PipelinedTestCase errPP errPreC errPostC input output -> input -> output

-- | Post conditions are checked after script execution
[$sel:postConditions:PipelinedTestCase] :: PipelinedTestCase errPP errPreC errPostC input output -> [PostCondition errPostC output]

-- | A sum type to collect the errors of a pipelined test case
data PipelinedTestErrors errPP errPreC errPostC
PipelinedPreProcessorError :: errPP -> PipelinedTestErrors errPP errPreC errPostC
PipelinedPreConditionError :: errPreC -> PipelinedTestErrors errPP errPreC errPostC
PipelinedPostConditionError :: errPostC -> PipelinedTestErrors errPP errPreC errPostC

-- | Behavior of this function:
--   
--   <ul>
--   <li>1.) All pre-processors are run in order from left to right on the
--   arguments. If any pre-processor returns a Left, then the resulting
--   test case fails with the appropriate error message.</li>
--   <li>2.) All pre-condition checks are run on the pre-processed
--   arguments. If any pre-condition checks return Nothing, then the
--   resulting test case fails with the appropriate error message.</li>
--   <li>3.) The pre-processed arguments are fed to the script.</li>
--   <li>4.) The results of (3) are checked against each post-condition. If
--   any of the post-condition checks fail, the test case fails with the
--   appropriate error message</li>
--   <li>5.) If none of the above checks cause a failure, the test
--   succeeds.</li>
--   </ul>
pipelinedUnitCase :: (Show errPP, Show errPreC, Show errPostC) => PipelinedTestCase errPP errPreC errPostC input output -> TestTree

-- | A sum type of the errors for a TxFCEKCase
data TxFCEKCase errPP errPreC errPostC

-- | The arguments needed to run a YTxP-style transaction family (single
--   script) on the CEK Machine. Includes a script context, and the script
--   itself.
data TxFCEKInput
TxFCEKInput :: ScriptContext -> Script -> TxFCEKInput
[$sel:cekScriptContext:TxFCEKInput] :: TxFCEKInput -> ScriptContext
[$sel:cekScript:TxFCEKInput] :: TxFCEKInput -> Script

-- | The data produced by the CEK machine when run against a TxFCEKInput.
data TxFCEKOutput
TxFCEKOutput :: Either EvalError Script -> ExBudget -> [Text] -> TxFCEKOutput
[$sel:cekResult:TxFCEKOutput] :: TxFCEKOutput -> Either EvalError Script
[$sel:cekExBudget:TxFCEKOutput] :: TxFCEKOutput -> ExBudget
[$sel:cekLogs:TxFCEKOutput] :: TxFCEKOutput -> [Text]

-- | Create a TxFCEKCase by filling in the computation via running the
--   script.
mkTxFCEKCase :: forall (errPP :: Type) (errPreC :: Type) (errPostC :: Type). String -> [PreProcessor errPP TxFCEKInput] -> [PreCondition errPreC TxFCEKInput] -> TxFCEKInput -> [PostCondition errPostC TxFCEKOutput] -> TxFCEKCase errPP errPreC errPostC
txfCEKUnitCase :: forall (errPP :: Type) (errPreC :: Type) (errPostC :: Type). (Show errPP, Show errPreC, Show errPostC) => TxFCEKCase errPP errPreC errPostC -> TestTree

-- | A post condition for checking whether the script execution succeeded
--   or failed You must supply a way to turn a generic evaluation error
--   into your domain-specific error type
nominalPostCondition :: ((EvalError, [Text]) -> err) -> PostCondition err TxFCEKOutput

-- | A basic nominal case unit test. Only checks if the script succeeds;
--   does not do pre-processing, pre-condition checking, or other
--   post-condition checks.
--   
--   Throws a generic <a>String</a> error (not domain-specific)
nominalCaseBasic :: String -> ScriptContext -> Script -> TxFCEKCase String String String

-- | The attackCaseRegex-style functions will fail with - A (Nothing,
--   [Text]) if the script succeeds. [Text] in the tuple contains the logs.
--   - A (Just Int, [Text]) if the script fails, but the regex does not
--   match exactly once. The int contains the number of matches
attackCaseRegexPostCondition :: ((Maybe Int, [Text]) -> err) -> RE -> PostCondition err TxFCEKOutput

-- | Generate an "attack case" test tree, given a name, an expected failure
--   condition, the arguments to the script, an attack, and the script
--   itself.
--   
--   The expected failure condition is matched as a regex. It must match
--   the logs exactly once.
attackCaseBasicRegex :: String -> RE -> ScriptContext -> Script -> PreProcessor errPP TxFCEKInput -> TxFCEKCase errPP String String
instance GHC.Show.Show Cardano.TestUtils.TxFCEKInput
instance GHC.Classes.Eq Cardano.TestUtils.TxFCEKInput
instance GHC.Show.Show Cardano.TestUtils.TxFCEKOutput
instance GHC.Classes.Eq Cardano.TestUtils.TxFCEKOutput

module Utils

-- | Convert a <tt>ScriptHash</tt> to a <tt>CurrencySymbol</tt>, which has
--   the same representation
pscriptHashToCurrencySymbol :: Term s PScriptHash -> Term s PCurrencySymbol
pmember :: PIsData k => Term s (k :--> (PMap any k v :--> PBool))
pcheck :: forall (s :: S). Term s PBool -> Term s PUnit


-- | in the Yielding Transaction Protocol (YTxP). It includes types and
--   functions for working with authorised scripts, yielding redeemers, and
--   retrieving script hashes.
--   
--   The module defines the following key components:
--   
--   <ul>
--   <li><a>PAuthorisedScriptPurpose</a>: An enumeration representing the
--   purpose of an authorised script, which can be minting, spending, or
--   rewarding.</li>
--   <li><a>PYieldingRedeemer</a>: A data type representing the redeemer
--   for yielding transactions. It includes an index for the authorised
--   script and a proof index.</li>
--   <li><a>getAuthorisedScriptHash</a>: A function that retrieves the hash
--   of an authorised script based on the provided currency symbol,
--   transaction reference inputs, and yielding redeemer.</li>
--   </ul>
--   
--   This module is part of the YTxP SDK and is designed to be used in
--   conjunction with other modules in the SDK to facilitate the creation
--   and validation of yielding transactions.
module Cardano.YTxP.Control.Yielding

-- | Retrieves the hash of an authorised script based on the provided
--   currency symbol, transaction reference inputs, and yielding redeemer.
getAuthorisedScriptHash :: forall (s :: S). Term s (PCurrencySymbol :--> (PBuiltinList (PAsData PTxInInfo) :--> (PYieldingRedeemer :--> PScriptHash)))

-- | A data type representing the purpose of an authorised script.
data PAuthorisedScriptPurpose (s :: S)
PMinting :: PAuthorisedScriptPurpose (s :: S)
PSpending :: PAuthorisedScriptPurpose (s :: S)
PRewarding :: PAuthorisedScriptPurpose (s :: S)

-- | A data type representing the redeemer for yielding transactions.
data PYieldingRedeemer (s :: S)
PYieldingRedeemer :: Term s (PAsData PAuthorisedScriptIndex) -> Term s (PAsData PAuthorisedScriptProofIndex) -> PYieldingRedeemer (s :: S)
[$sel:authorisedScriptIndex:PYieldingRedeemer] :: PYieldingRedeemer (s :: S) -> Term s (PAsData PAuthorisedScriptIndex)
[$sel:authorisedScriptProofIndex:PYieldingRedeemer] :: PYieldingRedeemer (s :: S) -> Term s (PAsData PAuthorisedScriptProofIndex)
instance Plutarch.Internal.Lift.PLiftable Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex
instance Plutarch.Internal.PlutusType.PlutusType Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex
instance Plutarch.Internal.IsData.PIsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex s)
instance Plutarch.Internal.PlutusType.PlutusType Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose
instance Plutarch.Internal.Eq.PEq Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose
instance Plutarch.Internal.IsData.PIsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Enum.Bounded (Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Enum.Enum (Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose s)
instance Plutarch.Internal.Lift.PLiftable Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex
instance Plutarch.Internal.PlutusType.PlutusType Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex
instance Plutarch.Internal.IsData.PIsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex s)
instance Plutarch.Internal.Lift.PLiftable Cardano.YTxP.Control.Yielding.PYieldingRedeemer
instance Plutarch.Internal.PlutusType.PlutusType Cardano.YTxP.Control.Yielding.PYieldingRedeemer
instance Plutarch.Internal.IsData.PIsData Cardano.YTxP.Control.Yielding.PYieldingRedeemer
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Cardano.YTxP.Control.Yielding.PYieldingRedeemer s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Cardano.YTxP.Control.Yielding.PYieldingRedeemer s)
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Cardano.YTxP.Control.Yielding.PYieldingRedeemer)
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptProofIndex)
instance Plutarch.Internal.Lift.PLiftable Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptPurpose)
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Cardano.YTxP.Control.Yielding.PAuthorisedScriptIndex)


-- | This module export a helper function that produces a two argument
--   yielding script that we use to implement the logic for yielding
--   validator, minting policy and staking validator
module Cardano.YTxP.Control.Yielding.Helper
yieldingHelper :: forall (s :: S). Term s (PCurrencySymbol :--> (PScriptContext :--> PUnit))

module Cardano.YTxP.Control.Yielding.Scripts

-- | Yielding Validator
yielding :: forall (s :: S). Term s (PCurrencySymbol :--> (PAsData PInteger :--> (PScriptContext :--> PUnit)))


-- | This module provides the blueprint for the Yielding Transaction
--   Pattern Library (ytxp-lib).
module Cardano.YTxP

-- | Generates the blueprint for the Yielding Transaction Pattern Library.
ytxpBlueprint :: Config -> SdkParameters -> ContractBlueprint
